# Reflection

Most of the libraries that parse/serialise data from/to human-readable formats usually rely on runtime reflection and an intermediate representation that acts as a bridge between the byte string and the source/resulting object. This means that this object is duplicated in memory, increasing the memory footprint of the process and slowing it down.

Using meta-programming, we can avoid the need for this intermediary object and runtime reflection, both when serialising and parsing data. By being able to query the definition of the data type, we can generate a serialisation function that fills a compile-time-generated byte string template, as well as a parsing function that uses a partially initialised object and set its fields iteratively.

This repository contains `reflection-serialiser` and `reflection-json-parser`, two Haskell libraries that allow serialising data to JSON and XML and parsing JSON data respectively, without relying on intermediary objects. The API of the serialiser is designed so that it can be used with user-defined human-readable formats.

The functions generated by these libraries can be up to 4 times faster than their equivalent from Aeson. Additional benchmarks show that our method can enable speed-ups up to 35\% in Rust, and 50\% in Golang, compared to each language's most popular JSON library.

## Examples

### Serialisation

```haskell
{-# LANGUAGE TypeApplications, TemplateHaskell #-}
import Data.Reflection.Serialiser
import Data.Reflection.Serialiser.Format.JSON
import Data.Reflection.Serialiser.Format.XML
import  Data.Reflection.Serialiser.Serialisable  (serialise)

newtype MySimpleRecord = MSR {a :: Int} 

-- Generates instances of `Serialisable`
genSerialisable @JSON ''MySimpleRecord
genSerialisable @XML ''MySimpleRecord

toJSON :: MySimpleRecord -> ByteString
toJSON = serialise @JSON

toXML :: MySimpleRecord -> ByteString
toXML = serialise @XML
```

### Parser (JSON only)

```haskell
import Data.JSON.FromJSON
import FlatParse.Basic (runParser, ParseResult)

data Book = Book
    { title :: String
    , releaseYear :: Integer
    , pageCount :: Integer
    , rating :: Double
    }
    deriving (Generic, Eq, Show)

-- Generates instance of `FromJSON`, provides `parse`
genFromJSON ''Book 

parseBook :: ByteString ->  ParseResult Book
parseBook = runParser . parse 
```
